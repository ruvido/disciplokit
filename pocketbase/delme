/// <reference path="../pb_data/types.d.ts" />

let botInterval = null;
let isRunning = false;
let lastUpdateId = 0;

// Get setting value by key
function getSetting(app, key) {
    try {
        console.log(`Looking for setting with key: ${key}`);
        const record = app.findFirstRecordByFilter("settings", `key = "${key}"`);
        if (record) {
            console.log(`Found setting ${key}:`, record.get("data"));
            return record.get("data");
        } else {
            console.log(`No setting found with key: ${key}`);
            return null;
        }
    } catch (e) {
        console.log(`Error getting setting ${key}:`, e.message);
        return null;
    }
}

// Generate secure linking parameter
function generateLinkParam(userId) {
    const timestamp = Date.now();
    const expiry = timestamp + (7 * 24 * 60 * 60 * 1000); // 7 days
    const hash = require('crypto').createHash('md5').update(`${userId}_${expiry}_disciplo_secret`).digest('hex').substring(0, 8);
    return `${userId}_${expiry}_${hash}`;
}

// Validate and extract user ID from link parameter
function validateLinkParam(param) {
    try {
        const parts = param.split('_');
        if (parts.length !== 3) return null;
        
        const userId = parts[0];
        const expiry = parseInt(parts[1]);
        const hash = parts[2];
        
        // Check if expired
        if (Date.now() > expiry) {
            console.log('Link expired');
            return null;
        }
        
        // Validate hash
        const expectedHash = require('crypto').createHash('md5').update(`${userId}_${expiry}_disciplo_secret`).digest('hex').substring(0, 8);
        if (hash !== expectedHash) {
            console.log('Invalid hash');
            return null;
        }
        
        return userId;
    } catch (e) {
        console.log('Error validating link param:', e.message);
        return null;
    }
}

// Long polling function
async function longPoll(app, botToken, timeout = 30) {
    try {
        const url = `https://api.telegram.org/bot${botToken}/getUpdates?offset=${lastUpdateId}&timeout=${timeout}`;
        const response = await fetch(url);
        const data = await response.json();
        
        if (!data.ok) {
            console.log('Telegram API error:', data);
            return;
        }
        
        if (data.result && data.result.length > 0) {
            // Process each update
            for (const update of data.result) {
                await processUpdate(app, botToken, update);
                lastUpdateId = update.update_id + 1;
            }
        }
        
    } catch (error) {
        console.log('Long polling error:', error.message);
    }
}

// Process telegram update
async function processUpdate(app, botToken, update) {
    try {
        if (!update.message || !update.message.text) return;
        
        const message = update.message;
        const chatId = message.chat.id;
        const text = message.text;
        
        // Handle /start command with parameter
        if (text.startsWith('/start ')) {
            const param = text.substring(7); // Remove '/start '
            const userId = validateLinkParam(param);
            
            if (!userId) {
                await sendMessage(botToken, chatId, '❌ Link non valido o scaduto. Genera un nuovo link dalla webapp.');
                return;
            }
            
            // Find member by ID
            const member = app.findRecordById("members", userId);
            if (!member) {
                await sendMessage(botToken, chatId, '❌ Utente non trovato. Assicurati di essere registrato sulla webapp.');
                return;
            }
            
            // Check if already linked
            if (member.get("telegram_id")) {
                await sendMessage(botToken, chatId, '✅ Account già collegato! Torna alla webapp per iscriverti ai gruppi.');
                return;
            }
            
            // Link account
            member.set("telegram_id", chatId.toString());
            member.set("telegram_name", message.from.first_name + (message.from.last_name ? ` ${message.from.last_name}` : ''));
            
            // Store additional telegram data
            const telegramData = {
                username: message.from.username || null,
                first_name: message.from.first_name,
                last_name: message.from.last_name || null,
                linked_at: new Date().toISOString()
            };
            member.set("data", JSON.stringify(telegramData));
            
            app.save(member);
            
            await sendMessage(botToken, chatId, 
                `✅ Account collegato con successo!\n\n` +
                `Ciao ${message.from.first_name}! Il tuo account Disciplo è ora collegato a Telegram.\n\n` +
                `🔗 Torna alla webapp per iscriverti ai gruppi disponibili.`
            );
            
        } else if (text === '/start') {
            await sendMessage(botToken, chatId, 
                `👋 Benvenuto nel bot Disciplo!\n\n` +
                `Per collegare il tuo account:\n` +
                `1. Vai sulla webapp Disciplo\n` +
                `2. Accedi alla tua area profilo\n` +
                `3. Clicca su "Collega Telegram"\n\n` +
                `Il bot ti permetterà di accedere ai gruppi della community.`
            );
        }
        
    } catch (error) {
        console.log('Error processing update:', error.message);
    }
}

// Send message to telegram
async function sendMessage(botToken, chatId, text) {
    try {
        const url = `https://api.telegram.org/bot${botToken}/sendMessage`;
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                chat_id: chatId,
                text: text,
                parse_mode: 'HTML'
            })
        });
        
        const data = await response.json();
        if (!data.ok) {
            console.log('Send message error:', data);
        }
    } catch (error) {
        console.log('Error sending message:', error.message);
    }
}

// Start bot polling
function startBot(app) {
    if (isRunning) {
        console.log('Telegram bot already running');
        return;
    }
    
    const botConfig = getSetting(app, "telegram_bot");
    console.log("Bot config loaded:", botConfig);
    
    if (!botConfig || !botConfig.token) {
        console.log('Bot token not configured');
        return;
    }
    
    if (!botConfig.active) {
        console.log('Bot disabled in settings');
        return;
    }
    
    const botToken = botConfig.token;
    
    console.log('Starting Telegram bot...');
    isRunning = true;
    
    // Initialize lastUpdateId if not set
    if (!lastUpdateId) {
        lastUpdateId = 0;
    }
    
    // Start polling loop
    const poll = async () => {
        if (!isRunning) return;
        
        await longPoll(app, botToken, pollingTimeout);
        
        // Continue polling if still running  
        if (isRunning) {
            // Use a simple promise delay instead of setTimeout
            new Promise(resolve => {
                let start = Date.now();
                while (Date.now() - start < 1000) {
                    // Busy wait for 1 second
                }
                resolve();
            }).then(poll);
        }
    };
    
    poll();
};

// Stop bot
const stopBot = function() {
    if (!isRunning) return;
    
    console.log('Stopping Telegram bot...');
    isRunning = false;
    
    if (botInterval) {
        clearInterval(botInterval);
        botInterval = null;
    }
};

// Start bot on hook load - MUST be at the very end after all functions are defined
onBootstrap((e) => {
    e.next();
    
    console.log('PocketBase server started - initializing Telegram bot');
    
    // Just try to read the setting directly
    try {
        const record = e.app.findFirstRecordByFilter("settings", `key = "telegram_bot"`);
        console.log("Found telegram_bot record:", record ? record.get("data") : "NOT FOUND");
        
        if (record) {
            const botConfigRaw = record.get("data");
            const botConfig = JSON.parse(botConfigRaw.string());
            console.log("botConfig after string parse:", botConfig);
            console.log("botConfig.token:", botConfig.token ? "EXISTS" : "MISSING");
            console.log("botConfig.active:", botConfig.active);
            
            if (botConfig && botConfig.token && botConfig.active) {
                console.log("Starting Telegram bot with token:", botConfig.token.substring(0, 10) + "...");
                let botRunning = true;
                let botLastUpdateId = 0;
                // Start simple polling here
                const poll = async () => {
                    if (!botRunning) return;
                    try {
                        console.log("Polling telegram for updates...");
                        // Inline longPoll code
                        const url = `https://api.telegram.org/bot${botConfig.token}/getUpdates?offset=${botLastUpdateId}&timeout=30`;
                        const response = await fetch(url);
                        const data = await response.json();
                        
                        if (data.ok && data.result && data.result.length > 0) {
                            console.log("Got", data.result.length, "updates");
                            for (const update of data.result) {
                                console.log("Processing update:", update.update_id);
                                botLastUpdateId = update.update_id + 1;
                            }
                        }
                    } catch (err) {
                        console.log("Poll error:", err.message);
                    }
                    if (botRunning) {
                        new Promise(resolve => {
                            let start = Date.now();
                            while (Date.now() - start < 1000) {}
                            resolve();
                        }).then(poll);
                    }
                };
                poll();
            } else {
                console.log("Bot not active or missing token");
            }
        }
    } catch (error) {
        console.log('Error reading settings:', error.message);
    }
});